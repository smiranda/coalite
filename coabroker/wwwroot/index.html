<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <title>coabroker</title>
    <base href="/" />
    

        <link href="css/bootstrap/bootstrap.min.css" rel="stylesheet" />
        <link href="css/app.css" rel="stylesheet" />
        <link href="coabroker.styles.css" rel="stylesheet" />
        
    
    <link rel="stylesheet" href="node_modules/xterm/css/xterm.css" />

    <script src="node_modules/xterm/lib/xterm.js"></script>
    <script src="node_modules/xterm-addon-fit/lib/xterm-addon-fit.js"></script>

    <script>

        var db;
        var request = indexedDB.open("Coabroker", 1);
        request.onerror = function (event) {
            console.error("Error creating database");
        };
        request.onsuccess = function (event) {
            db = event.target.result;
        };
        request.onupgradeneeded = function (event) {
            // Called either on (1) new database or on (2) version mismatch = needs upgrade.
            var db = event.target.result;
            // Create object stores
            var keyStore = db.createObjectStore("keys", { keyPath: "id" });
            var coaliteStore = db.createObjectStore("coalites", { keyPath: "id" });
            keyStore.createIndex("name", "name", { unique: false });
        };

        window.storeObject = (storeName, record) => {
            var objectStore = transaction.objectStore(storeName, "readwrite").add(record);
            return new Promise((resolve, reject) => {
                request.onerror = function (evt) {
                    var err = evt.target.errorCode;
                    console.error(err);
                    reject(err);
                };
                request.onsuccess = function (evt) {
                    resolve();
                };
            });
        };

        window.loadObject = (storeName, record) => {
            var objectStore = transaction.objectStore(storeName, "read").get(record);
            return new Promise((resolve, reject) => {
                request.onerror = function (evt) {
                    evt.target.errorCode;
                };
                request.onsuccess = function (event) {
                    if (typeof evt.target.result == 'undefined') {
                        console.log("No matching record found");
                        resolve(null);
                    }
                    resolve(JSON.stringify(evt.target.result));
                };
            });
        };

        window.bootFn = (msg) => {
            console.log(msg);
        };

        function stringToArrayBuffer(byteString) {
            var byteArray = new Uint8Array(byteString.length);
            for (var i = 0; i < byteString.length; i++) {
                byteArray[i] = byteString.codePointAt(i);
            }
            return byteArray;
        }
        function arrayBufferToString(exportedPrivateKey) {
            var byteArray = new Uint8Array(exportedPrivateKey);
            var byteString = '';
            for (var i = 0; i < byteArray.byteLength; i++) {
                byteString += String.fromCodePoint(byteArray[i]);
            }
            return byteString;
        }
        function b64EncodeUnicode(str) {
            return btoa(encodeURIComponent(str).replace(/%([0-9A-F]{2})/g, function (match, p1) {
                return String.fromCharCode('0x' + p1);
            }));
        };
        function base64StringToArrayBuffer(b64str) {
            var byteStr = atob(b64str)
            var bytes = new Uint8Array(byteStr.length)
            for (var i = 0; i < byteStr.length; i++) {
                bytes[i] = byteStr.charCodeAt(i)
            }
            return bytes.buffer
        }
        function ab2str(buf) {
            return String.fromCharCode.apply(null, new Uint8Array(buf));
        }

        window.generateKey = () => {
            return new Promise((resolve, reject) => {
                try {
                    window.crypto.subtle.generateKey(
                        {
                            name: "RSA-OAEP",
                            modulusLength: 4096,
                            publicExponent: new Uint8Array([1, 0, 1]),
                            hash: "SHA-256",
                        },
                        true,
                        ["encrypt", "decrypt"]
                    ).then(async (keyPair) => {
                        var pbk = await crypto.subtle.exportKey("spki", keyPair.publicKey);
                        var pvk = await crypto.subtle.exportKey("pkcs8", keyPair.privateKey);
                        var r = JSON.stringify(
                            {
                                publicKey: window.btoa(ab2str(pbk)),
                                privateKey: window.btoa(ab2str(pvk))
                            });
                        resolve(r);
                    });
                } catch (e) {
                    console.log(e);
                    reject(e);
                }
            });
        }


        // Read: https://stackoverflow.com/questions/38677742/cryptokey-arraybuffer-to-base64-and-back/38714970#38714970
        // Also interesting: https://docs.microsoft.com/en-us/aspnet/core/blazor/call-dotnet-from-javascript?view=aspnetcore-5.0
        window.signData = (privKey, data) => {
            try {
                //  console.log(privKey);~
                var signAlgorithm = {
                    name: "RSASSA-PKCS1-v1_5",
                    hash: "SHA-256",
                    modulusLength: 4096,
                    extractable: false,
                    publicExponent: new Uint8Array([1, 0, 1])
                }
                return new Promise((resolve, reject) => {
                    window.crypto.subtle.importKey(
                        "pkcs8",
                        base64StringToArrayBuffer(privKey),
                        signAlgorithm,
                        true,
                        ["sign"]
                    ).then(function (importedPrivateKey) {
                        try {
                            window.privateKey = importedPrivateKey;
                            window.crypto.subtle.sign(signAlgorithm, importedPrivateKey, base64StringToArrayBuffer(data))
                                .then(function (result) {
                                    //console.log(result);
                                    let b64r = btoa(String.fromCharCode.apply(null, new Uint8Array(result)));
                                    //console.log(b64r);
                                    resolve(b64r);
                                });

                        } catch (e) {
                            console.log(e);
                            reject(e);
                        }
                    });
                });
            } catch (e) {
                console.log(e);
            }
            return "";
        }

        window.runTerminalCommand = (cmd, cb) => {
            // check first local commands

            DotNet.invokeMethodAsync('coabroker', 'RunTerminalCommand', cmd)
                .then(data => {
                    console.log(data);
                    cb(data);
                });

        };
    </script>
</head>

<body style="margin: 0 !important;">
    <div id="app" style="color: white;">...</div>

    <div id="blazor-error-ui">
        An unhandled error has occurred.
        <a href="" class="reload">Reload</a>
        <a class="dismiss">ðŸ—™</a>
    </div>


    <script>
        setTimeout(() => {
            const term = new Terminal({
                cursorBlink: "block",
                scrollback: 1000,
                tabStopWidth: 4,
                fontSize: 42,
                fontFamily: 'Courier New',
                theme: {
                    background: '#2b1900',
                    foreground: '#ff9400',
                    cursor:'#ff9400'
                }
            });
            const fitAddon = new FitAddon.FitAddon();
            term.loadAddon(fitAddon);
            let currentLineBuffer = "";
            term.open(document.getElementById('terminal'));
            document.querySelector('.xterm-viewport').style.overflowY = 'hidden';
            document.querySelector('html').style.height = '100%';
            document.querySelector('body').style.height = '100%';
            document.querySelector('#app').style.height = '100%';
            document.querySelector('#terminal').style.height = '100%';
            document.querySelector('.terminal.xterm.xterm-dom-renderer-owner-1').style.height = '100%';
            document.querySelector('.xterm-viewport').style.height = '100%';
            document.querySelector('.xterm-screen').style.height = '100%';
            fitAddon.fit();
            // If you find more problems with terminal fit, explore this more : https://github.com/xtermjs/xterm.js/issues/3564
            window.onresize = function () {
                fitAddon.fit();
            };
            let simplePrompt = () => {
                term.write('$ ');
            };
            let prompt = () => {
                term.write('\r\n');
                simplePrompt();
            };
            simplePrompt();
            let exec = (c) => {
                if (c == "clear") {
                    term.reset();
                    currentLineBuffer = "";
                    simplePrompt();
                } else {
                    window.runTerminalCommand(c, (r) => {
                        if (r?.length > 0)
                            term.write(`\r\n${r}`);
                        currentLineBuffer = "";
                        prompt();
                    });
                }
            };
            // TEST 
            setInterval(()=>{ 
                let numchars = currentLineBuffer.length;
                while (numchars > 0) {
                    term.write('\b \b');
                    numchars--;
                }
                term.write(`\r\n[!] ${Math.random()}`); 
                prompt();
                term.write(currentLineBuffer);
            }, 1000);
            term.onKey((e) => {
                const ev = e.domEvent;
                const printable = !ev.altKey && !ev.ctrlKey && !ev.metaKey;

                if (ev.keyCode === 13) {
                    exec(currentLineBuffer);
                } else if (ev.keyCode === 8) {
                    // Do not delete the prompt
                    if (term._core.buffer.x > 2) {
                        term.write('\b \b');
                        if (currentLineBuffer.length > 0) {
                            currentLineBuffer = currentLineBuffer.slice(0, currentLineBuffer.length - 1);
                        }
                    }
                } else if (printable) {
                    term.write(e.key);
                    currentLineBuffer += e.key;
                }
            });

        }, 2000);
    </script>

    <script src="_framework/blazor.webassembly.js"></script>
</body>

</html>